<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.537">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>adverbial-clauses</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="14 - Adverbial Clauses_files/libs/clipboard/clipboard.min.js"></script>
<script src="14 - Adverbial Clauses_files/libs/quarto-html/quarto.js"></script>
<script src="14 - Adverbial Clauses_files/libs/quarto-html/popper.min.js"></script>
<script src="14 - Adverbial Clauses_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="14 - Adverbial Clauses_files/libs/quarto-html/anchor.min.js"></script>
<link href="14 - Adverbial Clauses_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="14 - Adverbial Clauses_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="14 - Adverbial Clauses_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="14 - Adverbial Clauses_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="14 - Adverbial Clauses_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="adverbial-clauses" class="level1">
<h1>14 - Adverbial clauses</h1>
<section id="mini-exercise" class="level2">
<h2 class="anchored" data-anchor-id="mini-exercise">Mini exercise</h2>
<ol type="1">
<li><p><u>When I fall in love</u>, it will be forever (sung by Nat King Cole)</p></li>
<li><p><u>Wherever I lay my hat</u>, that’s my home (sung by Marvin Gaye)</p></li>
<li><p><u>Whenever/wherever we’re meant to be together</u>, I’ll be there and you’ll be near (sung by Shakira)</p></li>
</ol>
<p>These all contain examples of ADVERBIAL CLAUSES (underlined)</p>
</section>
<section id="clauses" class="level2">
<h2 class="anchored" data-anchor-id="clauses">Clauses</h2>
<section id="definitions" class="level3">
<h3 class="anchored" data-anchor-id="definitions">Definitions</h3>
<p>A clause is a linguistic unit (phrase) which describes a <strong>situation</strong>. It must have a <strong>Verb</strong> (to describe the situation), and it must have at least one <strong>Argument</strong> (the entity involved in the situation). If there is only one argument, this will come in subject position.</p>
<p>Typically the verb will carry tense.</p>
<p>For the purposes of this course, a “clause” is indistinguishable from a “sentence”, e.g.</p>
<ol type="1">
<li>Jack likes cheese</li>
<li>Anita is the coolest person in the universe!</li>
</ol>
<p>Both of these can be described as <strong>sentences</strong> or <strong>clauses</strong>.</p>
</section>
<section id="unusual-types-of-clauses" class="level3">
<h3 class="anchored" data-anchor-id="unusual-types-of-clauses">Unusual types of clauses</h3>
<p>There are unusual types of clause which depart from the above definition. Some clauses can contain an <strong>implicit argument</strong> and a <strong>non-finite verb</strong>, e.g.</p>
<ol type="1">
<li>(My) <u>Being rich</u> is not my primary aim in life</li>
<li><u>To be rich</u> is not my primary aim in life</li>
<li>He told me <u>to be quiet</u></li>
</ol>
<p>However, we are not going to be focusing on these types of clauses in the course.</p>
</section>
<section id="what-is-the-purpose-of-clauses" class="level3">
<h3 class="anchored" data-anchor-id="what-is-the-purpose-of-clauses">What is the purpose of clauses?</h3>
<p>Clauses describe SITUATIONS which correspond to SCENES or MENTAL PICTURES. These scenes/mental pictures are essential to the way we think, express our thoughts, and categorise the world around us. (Nelson, K. (1999). Event representations, narrative development and internal working models. <em>Attachment &amp; Human Development</em>, <em>1</em>(3), 239–252.). Without clauses we wouldn’t really be able to communicate.</p>
</section>
<section id="so-why-not-just-use-the-term-sentence" class="level3">
<h3 class="anchored" data-anchor-id="so-why-not-just-use-the-term-sentence">So why not just use the term “sentence”</h3>
<p>We tend to use the term “Clause” as opposed to a “sentence” when there are multiple situations per sentence.</p>
</section>
<section id="dependentsubordinate-versus-main-clauses" class="level3">
<h3 class="anchored" data-anchor-id="dependentsubordinate-versus-main-clauses">Dependent/subordinate versus main clauses</h3>
<p>We distinguish between the main (or matrix) clause, and the dependent (or subordinate) clause, e.g.</p>
<ol type="1">
<li><p><u>When I fall in love</u> (SUB.), it will be forever (MAIN)</p></li>
<li><p><u>Wherever I lay my hat</u> (SUB.), that’s my home (MAIN)</p></li>
<li><p><u>Whenever/wherever we’re meant to be together</u> (SUB), I’ll be there and you’ll be near (MAIN)</p></li>
</ol>
<p>In the above examples, the dependent clause is (a) semantically backgrounded and (b) syntactically optional (the sentence sounds okay without it). However, the sentence would sound very odd without the main clause.</p>
<p>To test whether a clause is dependent, you might wish to try the “door test”. Imagine someone pops their head round the door, and says a clause. If that clause is the main clause, it will probably sound okay in isolation. (I wish to acknowledge former student Steve McCafferty for this test!)</p>
</section>
<section id="exercise" class="level3">
<h3 class="anchored" data-anchor-id="exercise">Exercise</h3>
<p>For the following sentences, identify the dependent and main clauses. Try to use the following tests</p>
<ol type="a">
<li><p>Are they syntactically <strong>optional</strong> (if yes, they are likely to be a dependent clause)</p></li>
<li><p>Are they <strong>movable</strong> (if yes, they are likely to be a dependent clause)</p></li>
<li><p>Are they semantically backgrounded? (if yes, the are likely to be a dependent clause)</p></li>
<li><p>Do they pass the “door” test (if no, they are likely to be a subordinate clause)</p></li>
</ol>
<ol type="1">
<li>You can’t come to the party unless you bring strawberries and champagne</li>
<li>You can bring books into the exam as long as they are placed on your desks.</li>
<li>While Nancy likes hot food, her partner cannot stand chilli pepper.</li>
<li>Nancy stood on tiptoe so that she could reach the top shelf</li>
<li>Because it had been raining so heavily the fields were all underwater.</li>
<li>When she was challenged about the stolen cake Dawn burst into tears.</li>
</ol>
</section>
</section>
<section id="adverbial-clauses-1" class="level2">
<h2 class="anchored" data-anchor-id="adverbial-clauses-1">Adverbial clauses</h2>
<p>All of the dependent clauses in the above examples are “Adverbial Clauses”. This is because the clause (including the “linking” words, e.g.&nbsp;<em>unless, as long as, while, so that, because</em>) fufils the function of an Adverbial. They are</p>
<ol type="1">
<li>Optional (like an adverbial)</li>
<li>Movable (like an adverbial)</li>
<li>Modify the event in the main clause (like an adverbial)</li>
</ol>
<p>Have a look at the following examples:</p>
<ol type="a">
<li>Prepositional Phrase acting as an Adverbial</li>
</ol>
<ol type="1">
<li>(Because of the rain) the fields were under water: phrase is OPTIONAL</li>
<li>The fields were underwater [ because of the rain ] : phrase is MOVABLE</li>
</ol>
<p>It also “modifies” the event in that it describes a reason for being underwater</p>
<ol start="2" type="a">
<li>Clause acting as an Adverbial</li>
</ol>
<ol type="1">
<li>(Because it had been raining heavily) the fields were under water: clause is OPTIONAL</li>
<li>The fields were underwater [ because it had been raining heavily ]: clause is MOVABLE</li>
</ol>
<p>It also “modifies” the event in that it describes the reason for being underwater</p>
</section>
<section id="subordinating-conjunctions" class="level2">
<h2 class="anchored" data-anchor-id="subordinating-conjunctions">Subordinating conjunctions</h2>
<section id="what-is-a-subordinating-conjunction" class="level3">
<h3 class="anchored" data-anchor-id="what-is-a-subordinating-conjunction">What is a subordinating conjunction?</h3>
<p>Adverbial clauses are headed by linking words known as <strong>subordinating conjunctions</strong>, or <strong>subordinators</strong>, e.g.&nbsp;<em>unless, as long as, while, so that, because</em>. They express a variety of different meanings including (a) Logical Conditions (e.g.&nbsp;<em>if</em>, <em>unless</em>, <em>provided that</em>, <em>as long as</em>), (b) Temporal Situations (e.g.&nbsp;<em>while</em>, <em>when</em>, <em>whenever</em>), (c) Cause and Effect (e.g.&nbsp;<em>because</em>, <em>since</em>, <em>so that</em>), Contradiction (e.g.&nbsp;<em>although</em>) and Contrast (e.g.&nbsp;<em>while, whereas</em>).</p>
<p>Subordinating conjunctions come before the clause, and the phrase which contains both the conjunction and the clause is described as the Adverbial Phrase:</p>
<ol type="1">
<li>[ <strong>Because</strong> [ it had been raining… <sub>(ADVERBIAL) CLAUSE&nbsp;</sub> ] <sub>ADVERBIAL PHRASE</sub> ]</li>
</ol>
<p>Subordinating conjunctions are like little pick-up trucks! When we add a subordinating conjunction to a sentence it becomes movable, e.g.</p>
<ol type="1">
<li>He had a good time at the party. He was tired.</li>
<li>He had a good time at the party, <strong>although</strong> he was tired.</li>
<li><strong>Although</strong> he was tired, he had a good time at the party.</li>
</ol>
</section>
<section id="subordinating-conjunctions-and-other-linking-words" class="level3">
<h3 class="anchored" data-anchor-id="subordinating-conjunctions-and-other-linking-words">Subordinating conjunctions and other linking words</h3>
<p>Subordinating conjunctions have similar meanings to other linking words:</p>
<ol type="1">
<li><strong>Although</strong> he was tired, he had a good time at the party. SUBORDINATING CONJUNCTION - acts like a pickup truck and makes the clause movable.</li>
<li>He was tired, <strong>but</strong> he had a good time at the party. COORDINATING CONJUNCTION - can only come between clauses.</li>
<li>He was tired. <strong>However</strong>, he had a good time at the party. ADVERB - can only come between sentences (note the full stop!)</li>
</ol>
</section>
<section id="the-importance-of-subordinating-conjunctions" class="level3">
<h3 class="anchored" data-anchor-id="the-importance-of-subordinating-conjunctions">The importance of subordinating conjunctions</h3>
<p>Subordinating conjunctions are very useful devices for linking events in a narrative.</p>
<p>They are assessed in many language assessments, e.g.&nbsp;the Formulating Sentences subtest of the CELF.</p>
<p>Language impaired individuals have great difficulties using subordinating conjunctions to introduce adverbial clauses. They have lower <strong>clausal</strong> density (number of clauses per sentence)</p>
</section>
<section id="exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1">Exercise</h3>
<p>For the following sentences:</p>
<ol type="a">
<li><p>Link them using a subordinating conjunction.</p></li>
<li><p>Do tests for the adverbial phrase (the movement test and “door” test)</p></li>
<li><p>Try to rewrite the sentence using either an Adverbial or a coordinating conjunction (not always possible)</p></li>
</ol>
<ol type="1">
<li>Touch that wire. You will be electrocuted.</li>
<li>Jack did not study very hard. He failed the exam.</li>
<li>Max can come to the party. He promises to behave himself.</li>
<li>Janice and Elena were on holiday. Their house was being burgled.</li>
<li>Jack added salt and pepper. The food tasted better.</li>
</ol>
</section>
</section>
<section id="clinical-applications" class="level2">
<h2 class="anchored" data-anchor-id="clinical-applications">Clinical applications</h2>
<p>Complex sentences are easier for children to understand / produce when their order is ‘iconic’ (de Ruiter, 2018). This means that the order of mention is the same as the order of occurrence, e.g.</p>
<ol type="1">
<li>ICONIC: <u>Because</u> the bus was late she missed the lecture</li>
<li>NON-ICONIC: She missed the lecture <u>because</u> the bus was late</li>
</ol>
<p>Note that whether the order is iconic or not will depend on the conjunction. If you use ‘so’, then to make the order iconic, the conjunction will come in the middle.</p>
<ol start="3" type="1">
<li>ICONIC: The bus was late <u>so</u> she missed the lecture.</li>
</ol>
<p>Therapists can manipulate iconicity in their intervention, e.g.&nbsp;give the most simple order first?</p>
<p>One way to teach children how conjunctions work is to use techniques such as ‘Shape-coding’ (Ebbels). This uses shapes and colours to show sentence structure. This technique can be used to show the two different orders of sentences containing subordinating conjunctions.</p>
<p>de Ruiter, L. E., Theakston, A. L., Brandt, S., &amp; Lieven, E. V. M. (2018). Iconicity affects children’s comprehension of complex sentences: The role of semantics, clause order, input and individual differences. <em>Cognition</em>, <em>171</em>, 202–224. https://doi.org/10.1016/j.cognition.2017.10.015</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>